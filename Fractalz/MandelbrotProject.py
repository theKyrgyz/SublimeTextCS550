# MandelbrotProject.py - [Lucas Eggers]
# DATE: October 23, 2018
# DESCRIPTION: Creates four images without any user input (as long as they have PIL and Python): two Mandelbrot fractal sections, and two Julia fractal sections.
#              Each has a different color scheme. 
# SOURCES: Documentation for complex numbers and PIL features: https://docs.python.org/3/library/functions.html?highlight=complex#complex , https://pillow.readthedocs.io/en/5.1.x/reference/ImageFilter.html
#          Dropbox file for Julia fractal set: https://www.dropbox.com/s/tie5910sltnkxq3/mandelbrot_reading.pdf?dl=0

# Importing some OS stuff, plus PIL's Image modules and the datetime module.
from PIL import Image, ImageFilter
import random, getpass
from datetime import date, datetime

# Lists to convert letters to B values in RGB, plus some modding lists - both for color scheme applications later.
letters = ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z"]
blueLetters = [180,102,70,47,0,185,222,100,0,112,150,94,63,100,0,50,0,25,135,208,37,205,213,74,74,12]
rMod6 = [0,50,100,150,200,250]

# Parameters for first image.
xmin, xmax, ymin, ymax, imgx, imgy, maxIt = -0.725935500641975308344, -0.725897875753086, 0.24088479052, 0.240922415407407407538, 1000, 1000, 256

# Getting the computer's username.
username = list(getpass.getuser().lower())

# Process to create the Mandelbrot fractal requested:
def mandelbrot(specify,VALCOL):
    # These next four lines turn every pixel value in the image into a point in the fractal, which then serves as a constant for the Mandlebrot equations.
    for y in range(imgy):
        cy = ((ymax-ymin)/(imgy-1))*y + ymin
        for x in range(imgx):
            cx = ((xmax-xmin)/(imgx-1))*x + xmin
            # Complex number creation.
            c = complex(cx,cy)
            z = 0
            for i in range(maxIt):
                # For each iteration, check whether z is bigger than 2. If not, square z and add the constant.
                global iCon
                iCon = i
                if abs(z) > 2.0:
                    break
                z = z**2 + c
            # COLOR SCHEME TIME!!
            if VALCOL == "M2":
                # Mandelbrot Method 2 - uses absolute values to create an offset dip, plus square roots.
                r = (iCon%30)*7
                g = abs(iCon-5)
                b = int(iCon**(1/2))*2
            else:
                # Mandelbrot Method 1 - forces more differentiation between higher-level iteration values [for the R value]. Good for borders.
                # The B value is generated by looking at the day of the week. I think it's cool.
                if iCon >= 256:
                    r = 0
                elif iCon > 222:
                    r = rMod6[(iCon-250)%6]
                else:
                    r = iCon
                g = (iCon*10)%3
                b = int((int(iCon+((datetime.now().day)%7))-int((x/4)))/2)
            specify.putpixel((x,y),(r,g,b))

# Julia fractal function. Similar to Mandelbrot in many ways but the actual calculation's different.
def julia(specify,cval,VALCOL):
    # First four lines serve similar purpose, but create the starting z value instead of the constant.
    for y in range(imgy):
        yJ = ((ymax-ymin)/(imgy-1))*y + ymin 
        # only doing it once per row... smart
        for x in range(imgx):
            xJ = ((xmax-xmin)/(imgx-1))*x + xmin
            # complex numbers:
            z = complex(xJ,yJ)
            for i in range(maxIt):
                # If |z| doesn't equal more than 2, square it and add the designated parameter 'cval', defined in the function call.
                global iCon
                iCon = i
                if abs(z) > 2.0:
                    break
                z = z**2 + cval
                # print(iCon)
                # print(z)
            # COLOR SCHEMES 2: ELECTRIC BOOGALOO(TM)
            if VALCOL == "J1":
                # Julia Method 1: Absolute values, plus it turns your computer username into the B value. If it starts with a letter.
                r = ((iCon%30)*7)+40
                g = abs(iCon-5)
                # A bodge - using lists to match letters with B values:
                if username[0] in letters:
                    for s in range(len(letters)):
                        if username[0] == letters[s]:
                            b = abs(blueLetters[s])
                else:
                    b = abs(150-iCon)
            elif VALCOL == "J2":
                # Julia Method 2: Changes the G value based on its location within the overall fractal. Uses some mods to create a low-resolution gradient, essentially.
                r = ((iCon%30)*7)+40
                g = ((int(xJ*100)%30))+100
                if username[0] in letters:
                    for s in range(len(letters)):
                        if username[0] == letters[s]:
                            b = abs(blueLetters[s])
                else:
                    b = abs(150-iCon)
            else:
                # Julia Method 0: A placeholder in case I want to add other methods later.
                r = iCon
                g = (iCon*10)%3
                b = 256-iCon
            specify.putpixel((x,y),(r,g,b))

### CREATING THE IMAGES - it makes them, saves them, and shows them. Thus it'll show as temporary pngs but they'll still be saved to the user's computer.


# The first image creation - 'Tunnels.' Works better at higher resolutions. Uses Mandelbrot, Color Method 1.
ImgC1 = Image.new("RGBA",(imgx,imgy))
ImgC1.paste((0,0,0), (0,0,imgx,imgy))
ImgC1.save("ImgC1.png","PNG")
mandelbrot(ImgC1,"M1")
ImgC1 = ImgC1.filter(ImageFilter.SHARPEN)
ImgC1.save("ImgC1.png","PNG")
ImgC1.show()


# The second image - 'September.' Uses Mandelbrot, Color Method 2. 
xmin, xmax = -1.786400592936561140507, -1.786395803871461587019
ymin, ymax = -0.000002098513044253179, 0.000001493285780411937
ImgC3 = Image.new("RGBA",(imgx,imgy))
ImgC3.paste((0,0,0), (0,0,imgx,imgy))
ImgC3.save("ImgC3.png","PNG")
VALCOL = "M2"
mandelbrot(ImgC3,"M2")
ImgC3.save("ImgC3.png","PNG")
ImgC3.show()

# The third image - 'Archipelago.' Uses Julia, Method 1, plus some Image Filtering from PIL to enhance color borders.
xmin, xmax = 0.2, 0.25
ymin, ymax = -0.60, -0.55
imgx, imgy = 1500,1500
maxIt = 200
ImgC4 = Image.new("RGBA",(imgx,imgy))
ImgC4.paste((0,0,0), (0,0,imgx,imgy))
julia(ImgC4,complex(0.5,-0.3),"J1")
ImgC41 = ImgC4.filter(ImageFilter.EDGE_ENHANCE_MORE)
ImgC42 = ImgC4.filter(ImageFilter.CONTOUR)
ImgC4F = Image.blend(ImgC41, ImgC42, 0.05)
ImgC4F.save("ImgC4.png","PNG")
ImgC4F.show()

# The fourth image - 'Quartz.' Uses Julia, Method 2.
xmin, xmax = 0.65, 0.75
ymin, ymax = -0.1, 0
imgx, imgy = 1000,1000
maxIt = 200
ImgC5 = Image.new("RGBA",(imgx,imgy))
julia(ImgC5,complex(-0.5,0.55),"J2")
ImgC5 = ImgC5.filter(ImageFilter.SHARPEN)
ImgC5.save("ImgC5.png","PNG")
ImgC5.show()


